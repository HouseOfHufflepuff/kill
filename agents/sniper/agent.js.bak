const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");
require("dotenv").config();

const YEL = "\x1b[33m"; const CYA = "\x1b[36m"; const PNK = "\x1b[35m"; const RES = "\x1b[0m"; const BRIGHT = "\x1b[1m";

function getCoords(id) {
    const v = id - 1;
    return { x: v % 6, y: Math.floor(v / 6) % 6, z: Math.floor(v / 36) };
}

function getId(x, y, z) { return (z * 36) + (y * 6) + x + 1; }

function getPath3D(startId, endId) {
    let current = getCoords(startId);
    const target = getCoords(endId);
    const path = [];
    while (current.x !== target.x || current.y !== target.y || current.z !== target.z) {
        let fromId = getId(current.x, current.y, current.z);
        if (current.x !== target.x) current.x += (target.x > current.x ? 1 : -1);
        else if (current.y !== target.y) current.y += (target.y > current.y ? 1 : -1);
        else if (current.z !== target.z) current.z += (target.z > current.z ? 1 : -1);
        path.push({ from: fromId, to: getId(current.x, current.y, current.z) });
    }
    return path;
}

async function main() {
    if (!process.env.SNIPER_PK) throw new Error("Missing SNIPER_PK in .env");
    const wallet = new ethers.Wallet(process.env.SNIPER_PK, ethers.provider);
    const config = JSON.parse(fs.readFileSync(path.join(__dirname, "config.json"), "utf8"));
    const { HUB_STACK, LOOP_DELAY_SECONDS, KILL_MULTIPLIER, SPAWN_PROFITABILITY_THRESHOLD, MIN_SPAWN } = config.settings;
    const { kill_game_addr, kill_faucet_addr } = config.network;
    
    const killGame = new ethers.Contract(kill_game_addr, JSON.parse(fs.readFileSync(path.join(__dirname, '../../data/abi/KILLGame.json'), 'utf8')).abi, wallet);
    const killTokenAddr = await killGame.killToken();
        const erc20Abi = [
        "function balanceOf(address) view returns (uint256)",
        "function allowance(address, address) view returns (uint256)",
        "function approve(address, uint256) returns (bool)",
        "function transfer(address, uint256) returns (bool)"
    ];
    const killToken = new ethers.Contract(killTokenAddr, erc20Abi, wallet);

    const faucetAbi = ["function pullKill() external", "function hasClaimed(address) view returns (bool)"];
    const killFaucet = new ethers.Contract(kill_faucet_addr, JSON.parse(fs.readFileSync(path.join(__dirname, '../../data/abi/KILLFaucet.json'), 'utf8')).abi, wallet);
    
    const SPAWN_COST_PER_UNIT = 10; 
    const REAPER_BOUNTY = 3330; 

    console.log(`${BRIGHT}--- SNIPER AGENT ONLINE ---${RES}`);

    try {
        const alreadyClaimed = await killFaucet.hasClaimed(wallet.address);
        if (!alreadyClaimed) {
            console.log(`${YEL}[STARTUP] Claiming faucet...${RES}`);
            const faucetTx = await killFaucet.pullKill({ gasLimit: 200000 });
            await faucetTx.wait();
            console.log(`${CYA}[SUCCESS] 666,000 KILL claimed.${RES}`);
        } else {
            console.log(`[STARTUP] Faucet already claimed.`);
        }
    } catch (e) {
        console.log(`${PNK}[STARTUP] Faucet skipped: ${e.reason || e.message}${RES}`);
    }

    while (true) {
        try {
            const ethBal = await ethers.provider.getBalance(wallet.address);
            const killBal = await killToken.balanceOf(wallet.address);
            const killAllow = await killToken.allowance(wallet.address, kill_game_addr);

            const scanIds = Array.from({ length: 216 }, (_, i) => i + 1);
            const stackCalls = scanIds.map(id => killGame.interface.encodeFunctionData("getFullStack", [id]));
            const results = await killGame.callStatic.multicall(stackCalls);
            
            let myStrandedStacks = [];
            let targets = [];

            for (let i = 0; i < 216; i++) {
                const stackId = i + 1;
                const items = killGame.interface.decodeFunctionResult("getFullStack", results[i])[0];
                const self = items.find(it => it.occupant.toLowerCase() === wallet.address.toLowerCase());
                const enemies = items.filter(it => it.occupant.toLowerCase() !== wallet.address.toLowerCase() && it.units.gt(0));

                if (self && stackId !== HUB_STACK && (self.units.gt(0) || self.reapers.gt(0))) {
                    myStrandedStacks.push({ id: stackId, units: self.units, reapers: self.reapers });
                }

                for (const e of enemies) {
                    const bountyVal = e.units.mul(SPAWN_COST_PER_UNIT).add(e.reapers.mul(REAPER_BOUNTY));
                    let spawnAmt = e.units.mul(KILL_MULTIPLIER);
                    if (spawnAmt.lt(MIN_SPAWN)) spawnAmt = ethers.BigNumber.from(MIN_SPAWN);
                    
                    // Logic fix: Calculate reapers generated by spawnAmt
                    const spawnReaper = spawnAmt.div(666);
                    const totalPower = spawnAmt.add(spawnReaper.mul(666));
                    const attackCost = totalPower.mul(SPAWN_COST_PER_UNIT);

                    const ratio = parseFloat(bountyVal.mul(1000).div(attackCost.gt(0) ? attackCost : 1).toString()) / 1000;
                    targets.push({ id: stackId, enemy: e, ratio, spawnAmt, spawnReaper, bountyVal, attackCost });
                }
            }

            console.clear();
            console.log(`${BRIGHT}--- SNIPER AGENT | STATUS ---${RES}`);
            console.table([{
                ETH: ethers.utils.formatEther(ethBal).substring(0, 6),
                KILL: (parseFloat(ethers.utils.formatEther(killBal))).toFixed(1) + "K",
                APPROVED: killAllow.gt(ethers.constants.MaxUint256.div(2)) ? "MAX" : (parseFloat(ethers.utils.formatEther(killAllow))).toFixed(1) + "K"
            }]);

            if (myStrandedStacks.length > 0) {
                console.log(`\n${BRIGHT}${PNK}STRANDED UNITS${RES}`);
                myStrandedStacks.forEach(s => {
                    const hops = getPath3D(s.id, HUB_STACK).length;
                    console.log(`ID: ${s.id.toString().padEnd(4)} | Units: ${s.units.toString().padEnd(6)} | Hops: ${hops}`);
                });
            }

            console.log(`\n${BRIGHT}ID   | ENEMY      | UNITS | BOUNTY   | RATIO | STATUS${RES}`);
            console.log(`-----|------------|-------|----------|-------|-------`);
            targets.sort((a,b) => b.ratio - a.ratio).slice(0, 10).forEach(t => {
                const isPass = t.ratio >= SPAWN_PROFITABILITY_THRESHOLD;
                const bountyStr = (parseFloat(t.bountyVal.toString()) / 1000).toFixed(1) + "K";
                let status = !isPass ? "LOW_ROI" : (killBal.lt(t.attackCost) ? "NO_KILL" : CYA + "READY" + RES);
                console.log(`${t.id.toString().padEnd(4)} | ${t.enemy.occupant.slice(0,10)} | ${t.enemy.units.toString().padEnd(5)} | ${bountyStr.padEnd(8)} | ${t.ratio.toFixed(2)}x | ${status}`);
            });

            const calls = [];
            if (myStrandedStacks.length > 0) {
                const s = myStrandedStacks[0];
                const moveStep = getPath3D(s.id, HUB_STACK)[0];
                console.log(`\n${YEL}[RETREAT] Moving ${s.id} -> ${moveStep.to}${RES}`);
                calls.push(killGame.interface.encodeFunctionData("move", [moveStep.from, moveStep.to, s.units, s.reapers]));
            } else {
                const best = targets.sort((a, b) => b.ratio - a.ratio)[0];
                if (best && best.ratio >= SPAWN_PROFITABILITY_THRESHOLD) {
                    if (killBal.gte(best.attackCost)) {
                        if (killAllow.lt(best.attackCost)) {
                            console.log(`${YEL}[AUTH] Approving...${RES}`);
                            await (await killToken.connect(wallet).approve(kill_game_addr, ethers.constants.MaxUint256)).wait();
                        }
                        if (ethBal.gt(ethers.utils.parseEther("0.002"))) {
                            console.log(`\n${PNK}[ATTACK] Snipe ${best.id} | Ratio: ${best.ratio}x | Reaper: ${best.spawnReaper}${RES}`);
                            calls.push(killGame.interface.encodeFunctionData("spawn", [best.id, best.spawnAmt]));
                            // Logic fix: Send both units AND the reapers generated from the spawn
                            calls.push(killGame.interface.encodeFunctionData("kill", [best.enemy.occupant, best.id, best.spawnAmt, best.spawnReaper]));
                        }
                    }
                }
            }

            if (calls.length > 0) {
                const tx = await killGame.connect(wallet).multicall(calls, { gasLimit: 2500000 });
                console.log(`${CYA}>> [TX]: ${tx.hash}${RES}`);
                await tx.wait();
            }
        } catch (err) { console.error("\n[ERROR]", err.message); }
        await new Promise(r => setTimeout(r, LOOP_DELAY_SECONDS * 1000));
    }
}
main();